import boto3
import json
import gzip
import time

S3_BUCKET_NAME = "your-cloudtrail-log-bucket"
DYNAMODB_TABLE_NAME = "IAMThreatLogs"

s3 = boto3.client("s3")
dynamodb = boto3.resource("dynamodb")
client = boto3.client("dynamodb")

# Function to check and create the table
def check_and_create_table():
    existing_tables = client.list_tables()["TableNames"]
    
    if DYNAMODB_TABLE_NAME not in existing_tables:
        print(f"Table {DYNAMODB_TABLE_NAME} not found. Creating...")
        client.create_table(
            TableName=DYNAMODB_TABLE_NAME,
            AttributeDefinitions=[{"AttributeName": "eventID", "AttributeType": "S"}],
            KeySchema=[{"AttributeName": "eventID", "KeyType": "HASH"}],
            BillingMode="PAY_PER_REQUEST"
        )

        # Wait until the table is active
        waiter = client.get_waiter("table_exists")
        waiter.wait(TableName=DYNAMODB_TABLE_NAME)
        print(f"Table {DYNAMODB_TABLE_NAME} created successfully!")

# Lambda function
def lambda_handler(event, context):
    check_and_create_table()  # Ensure table exists before inserting logs

    print("Received event:", json.dumps(event, indent=4))

    try:
        # Extract S3 object key
        if "Records" in event and len(event["Records"]) > 0 and "s3" in event["Records"][0]:
            bucket_name = event["Records"][0]["s3"]["bucket"]["name"]
            object_key = event["Records"][0]["s3"]["object"]["key"]
        else:
            bucket_name = S3_BUCKET_NAME
            object_key = "AWSLogs/123456789012/CloudTrail/us-east-1/2025/03/06/correct-log-file.json.gz"

        print(f"Fetching file: {object_key} from bucket: {bucket_name}")

        response = s3.get_object(Bucket=bucket_name, Key=object_key)
        log_data = gzip.decompress(response["Body"].read()).decode("utf-8")
        cloudtrail_events = json.loads(log_data)["Records"]

        table = dynamodb.Table(DYNAMODB_TABLE_NAME)
        for log in cloudtrail_events:
            log["eventID"] = log.get("eventID", str(time.time()))  # Ensure primary key exists
            table.put_item(Item=log)

        return {"status": "IAM logs stored in DynamoDB"}

    except Exception as e:
        print(f"Error processing event: {e}")
        return {"status": "Error processing event", "error": str(e)}

import boto3
import json

# AWS Clients
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table("IAMThreatLogs")
bedrock = boto3.client("bedrock-runtime")  # AWS Bedrock Runtime API

# Define Suspicious Actions
SUSPICIOUS_ACTIONS = [
    "AttachRolePolicy", "PassRole", "CreateUser", "CreateAccessKey", "DeleteUser"
]

# Lambda Function
def lambda_handler(event, context):
    response = table.scan(Limit=10)  # Get recent 10 logs
    logs = response["Items"]

    findings = []
    
    for log in logs:
        if log["eventName"] in SUSPICIOUS_ACTIONS:
            prompt = f"Analyze this IAM event for security risks:\n{json.dumps(log, indent=2)}"
            
            # Call AWS Bedrock (Replace model with actual Bedrock-supported model)
            bedrock_response = bedrock.invoke_model(
                modelId="anthropic.claude-v2",
                body=json.dumps({"prompt": prompt, "max_tokens_to_sample": 200})
            )
            
            result = json.loads(bedrock_response["body"].read().decode("utf-8"))
            risk_assessment = result.get("completion", "No analysis available")

            findings.append({
                "event": log["eventName"],
                "user": log["userIdentity"]["arn"],
                "risk_assessment": risk_assessment
            })
    
    return {"status": "Analysis Complete", "findings": findings}

import boto3
import json
import base64

# AWS Clients
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table("IAMThreatLogs")
bedrock = boto3.client("bedrock-runtime")  # AWS Bedrock Runtime API

# Define Suspicious Actions
SUSPICIOUS_ACTIONS = [
    "AttachRolePolicy", "PassRole", "CreateUser", "CreateAccessKey", "DeleteUser"
]

# Function to generate embeddings using Titan Embeddings
def get_text_embedding(text):
    payload = {
        "inputText": text
    }

    response = bedrock.invoke_model(
        modelId="amazon.titan-embed-text-v1",
        body=json.dumps(payload)
    )
    
    response_body = json.loads(response["body"].read().decode("utf-8"))
    return response_body["embedding"]

# Lambda Function
def lambda_handler(event, context):
    response = table.scan(Limit=10)  # Get recent 10 logs
    logs = response["Items"]

    findings = []
    
    for log in logs:
        if log["eventName"] in SUSPICIOUS_ACTIONS:
            event_text = json.dumps(log, indent=2)
            embedding = get_text_embedding(event_text)  # Convert log event to vector
            
            findings.append({
                "event": log["eventName"],
                "user": log["userIdentity"]["arn"],
                "embedding": embedding  # Store embedding for threat analysis
            })
    
    return {"status": "Analysis Complete", "findings": findings}
SUSPICIOUS_ACTIONS = [
    # ðŸš¨ Privilege Escalation
    "AttachRolePolicy", "DetachRolePolicy", "PassRole", "UpdateAssumeRolePolicy",
    "CreatePolicyVersion", "SetDefaultPolicyVersion",

    # ðŸš¨ User & Role Management
    "CreateUser", "DeleteUser", "UpdateUser",
    "CreateRole", "DeleteRole", "UpdateRole",
    "AddUserToGroup", "RemoveUserFromGroup",

    # ðŸš¨ Access Key & Login Profile (Account Takeover)
    "CreateAccessKey", "DeleteAccessKey", "UpdateAccessKey",
    "CreateLoginProfile", "UpdateLoginProfile", "DeleteLoginProfile",

    # ðŸš¨ Policy & Permissions Management
    "CreatePolicy", "DeletePolicy", "PutUserPolicy", "DeleteUserPolicy",
    "PutRolePolicy", "DeleteRolePolicy",

    # ðŸš¨ MFA & Security Controls Bypass
    "DeactivateMFADevice", "EnableMFADevice", "ResyncMFADevice",
    "UpdateAccountPasswordPolicy",

    # ðŸš¨ Assume Role (Lateral Movement)
    "AssumeRole", "GetSessionToken", "GetFederationToken",

    # ðŸš¨ Service-Linked Role Modifications
    "DeleteServiceLinkedRole", "UpdateServiceLinkedRole",

    # ðŸš¨ Instance Profile Manipulation (AWS Resource Takeover)
    "CreateInstanceProfile", "DeleteInstanceProfile",
    "AddRoleToInstanceProfile", "RemoveRoleFromInstanceProfile",

    # ðŸš¨ Credential & Secrets Exposure
    "GetSecretValue", "PutSecretValue", "DeleteSecret",
    "GetParameter", "PutParameter", "DeleteParameter",

    # ðŸš¨ CloudTrail & Logging Manipulation (Covering Tracks)
    "StopLogging", "DeleteTrail", "UpdateTrail",
    "PutEventSelectors", "PutInsightSelectors"
]

import boto3
import json

# AWS Clients
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table("IAMThreatLogs")
bedrock = boto3.client("bedrock-runtime")  # AWS Bedrock Runtime API

# Define Suspicious Actions
SUSPICIOUS_ACTIONS = [
    "AttachRolePolicy", "PassRole", "CreateUser", "CreateAccessKey", "DeleteUser",
    "AssumeRole", "UpdateAssumeRolePolicy", "StopLogging"
]

# Lambda Function
def lambda_handler(event, context):
    response = table.scan(Limit=10)  # Get recent 10 logs
    logs = response["Items"]

    findings = []
    
    for log in logs:
        if log["eventName"] in SUSPICIOUS_ACTIONS:
            # âœ… Safely extract user ARN or fallback to "Unknown"
            user_identity = log.get("userIdentity", {})
            user_arn = user_identity.get("arn", user_identity.get("principalId", "Unknown"))

            prompt = f"Analyze this IAM event for security risks:\n{json.dumps(log, indent=2)}"
            
            # Call AWS Bedrock Titan Embedding
            bedrock_response = bedrock.invoke_model(
                modelId="amazon.titan-embed-text-v1",  
                body=json.dumps({"prompt": prompt, "max_tokens_to_sample": 200})
            )
            
            result = json.loads(bedrock_response["body"].read().decode("utf-8"))
            risk_assessment = result.get("completion", "No analysis available")

            findings.append({
                "event": log["eventName"],
                "user": user_arn,
                "risk_assessment": risk_assessment
            })
    
    return {"status": "Analysis Complete", "findings": findings}


import boto3
import json

# AWS Clients
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table("IAMThreatLogs")
bedrock = boto3.client("bedrock-runtime")  # AWS Bedrock Runtime API

# Define Suspicious Actions
SUSPICIOUS_ACTIONS = [
    "AttachRolePolicy", "PassRole", "CreateUser", "CreateAccessKey", "DeleteUser",
    "AssumeRole", "UpdateAssumeRolePolicy", "StopLogging"
]

# Lambda Function
def lambda_handler(event, context):
    response = table.scan(Limit=10)  # Get recent 10 logs
    logs = response["Items"]

    findings = []
    
    for log in logs:
        if log["eventName"] in SUSPICIOUS_ACTIONS:
            # âœ… Safely extract user ARN or fallback to "Unknown"
            user_identity = log.get("userIdentity", {})
            user_arn = user_identity.get("arn", user_identity.get("principalId", "Unknown"))

            # âœ… Titan requires "inputText" instead of "prompt"
            request_body = json.dumps({"inputText": json.dumps(log, indent=2)})

            try:
                # Call AWS Bedrock Titan Embedding
                bedrock_response = bedrock.invoke_model(
                    modelId="amazon.titan-embed-text-v1",  
                    body=request_body
                )
                
                result = json.loads(bedrock_response["body"].read().decode("utf-8"))
                embeddings = result.get("embedding", [])  # Titan returns embeddings

                findings.append({
                    "event": log["eventName"],
                    "user": user_arn,
                    "embeddings": embeddings[:5]  # Show first 5 values for testing
                })
            
            except Exception as e:
                findings.append({
                    "event": log["eventName"],
                    "user": user_arn,
                    "error": str(e)
                })

    return {"status": "Analysis Complete", "findings": findings}

import boto3
import json

# AWS Clients
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table("IAMThreatLogs")
bedrock = boto3.client("bedrock-runtime")  # AWS Bedrock Runtime API

# Define Suspicious Actions
SUSPICIOUS_ACTIONS = [
    "AttachRolePolicy", "PassRole", "CreateUser", "CreateAccessKey", "DeleteUser",
    "AssumeRole", "UpdateAssumeRolePolicy", "StopLogging", "PutRolePolicy", "DeleteRolePolicy"
]

# Lambda Function
def lambda_handler(event, context):
    response = table.scan(Limit=10)  # Get recent 10 logs
    logs = response["Items"]

    findings = []
    
    for log in logs:
        if log["eventName"] in SUSPICIOUS_ACTIONS:
            # âœ… Extract user ARN safely
            user_identity = log.get("userIdentity", {})
            user_arn = user_identity.get("arn", user_identity.get("principalId", "Unknown"))

            # âœ… Use Claude 3 for threat analysis
            request_body = json.dumps({
                "prompt": f"Analyze this IAM event and detect potential threats:\n{json.dumps(log, indent=2)}",
                "max_tokens": 500,
                "temperature": 0.2
            })

            try:
                # Call AWS Bedrock Claude 3 Model
                bedrock_response = bedrock.invoke_model(
                    modelId="anthropic.claude-3",
                    body=request_body
                )

                result = json.loads(bedrock_response["body"].read().decode("utf-8"))
                risk_assessment = result.get("completion", "No analysis available")

                findings.append({
                    "event": log["eventName"],
                    "user": user_arn,
                    "risk_assessment": risk_assessment
                })
            
            except Exception as e:
                findings.append({
                    "event": log["eventName"],
                    "user": user_arn,
                    "error": str(e)
                })

    return {"status": "Analysis Complete", "findings": findings}
